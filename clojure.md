# Clojure
## Обзорная часть

Clojure (произносится как closure [ˈklōZHər]) — современный диалект Лиспа, язык программирования общего назначения с поддержкой разработки в интерактивном режиме, поощряющий функциональное программирование и упрощающий поддержку многопоточности. Clojure работает на платформах JVM и CLR. Clojure отличает философия «код как данные» (гомоиконность) и развитая система лисп-макросов.

### Синтаксис

Как и в любом другом Лиспе, синтаксис Clojure основан на S-выражениях, которые перед компиляцией транслируются синтаксическим анализатором в структуры данных. Синтаксический анализатор Clojure поддерживает, помимо обычных списков, синтаксис литералов для ассоциативных массивов, множеств и векторов, передавая затем все эти структуры данных компилятору. Иначе говоря, компилятор Clojure компилирует не только списковые структуры данных, но и напрямую поддерживает все указанные типы.

Хотя Clojure является расширением изначальной версии Lisp, он не совместим с Lisp’ом, то есть программа на любой из современных версий Lisp’а (за исключением, возможно, самых коротких, примитивных и, к тому же, специально подобранных примеров) либо вообще не пройдёт транслятор Clojure, либо будет выполняться неправильно. Отличия от распространённых версий Lisp’а приведены на сайте языка. Вот некоторые из них:

* идентификаторы регистро-зависимы;
* оригинальный синтаксис для литералов, векторов, отображений (maps), регулярных выражений, анонимных функций и ряда других синтаксических элементов;
* утрачена многозначность значения nil (которое в Lisp обозначает и пустой указатель, и пустой список, и логическое значение «ложь») — оно означает только отсутствующее значение (пустую ссылку, подобно null в Java), для прочих значений используется специфический синтаксис;
* многие традиционные функции поменяли имена, например, car и cdr заменены на first и rest;
* поддерживаются одноимённые функции с различными наборами аргументов;
* отсутствуют макросы чтения (read macros), что лишает возможности изменять синтаксис языка;
* часть оставшихся неизменными синтаксических элементов изменили смысл;
* появилась поддержка «ленивых» коллекций.

### Макросы

Макросистема Clojure очень похожа на аналогичную систему Common Lisp, за двумя исключениями:

* При раскрытии форм под знаком обратной кавычки ` (англ. back quote), который в Clojure именуется термином «syntax-quote», происходит автоматическая явная квалификация каждого символа тем пространством имён, к которому он относится в точке определения макроса. Такой порядок исключает непреднамеренное связывание с одноимённым символом из «чужого» пространства имён при раскрытии макроса. Сослаться в макросе на символ из другого пространства имён возможно, но только путём его явной квалификации.
* Для выделения промежуточных вычислений под знаком обратной кавычки вместо `,` и `,@` используются `~` и `~@` соответственно.

### Особенности языка

* Динамическая, интерактивная разработка в REPL-цикле
* Функции как объекты первого класса с акцентом на рекурсию, а не на основанную на побочных эффектах итерацию
* «Ленивые» последовательности
* Обеспечивает богатый набор неизменяемых, сохраняемых структур данных (англ.)
* Параллельное программирование с поддержкой транзакционной памяти, агентной системы и системы динамических переменных
* Clojure — компилируемый язык, результатом компиляции является байткод JVM
* Тесная интеграция с Java: за счёт компиляции в байткод JVM программы на Clojure легко переносятся в любую среду с JVM. Язык также обеспечивает ряд макросов, которые упрощают использование в нём существующих Java API. Структуры данных Clojure реализуют все стандартные интерфейсы Java, что делает легким запуск из Java программного кода написанного на Clojure.

### Примеры

Hello World:
```lisp
(println "Привет, мир!")
```

Потокобезопасный генератор уникальных серийных номеров:
```lisp
(let [i (atom 0)]
  (defn generate-unique-id
    "Возвращает различные числовые ID для каждого вызова."
    []
    (swap! i inc)))
```

Анонимный подкласс java.io.Writer который ничего не выводит, и макрос используемый, чтобы заглушить весь вывод внутри него:
```lisp
(def bit-bucket-writer
  (proxy [java.io.Writer] []
    (write [buf] nil)
    (close []    nil)
    (flush []    nil)))

(defmacro noprint
  "Вычисляет заданные выражения, заглушая весь *вывод* на экран".
  [& forms]
  `(binding [*out* bit-bucket-writer]
     ~@forms))

(noprint
 (println "Hello, nobody!"))
 ```

### Применение

С увеличением интереса к функциональным языкам программирования, использование Clojure программистами Java платформы продолжает расти.

В "JVM Ecosystem Report 2018" Clojure занял 2 место среди самых применяемых (после Java) для разработки приложений.

Clojure используется такими компаниями как Apple, Atlassian, Funding Circle, Netflix, Puppet, Walmart а также NASA. Он также использовался для творческих вычислений, включая визуальное искусство, музыку, игры и поэзию.

Растущее число неофициальных и эксперементальных реализаций для других платформ показывает популярность языка:
    CljPerl, Clojure для Perl
    Clojerl, Clojure на BEAM, для Erlang
    clojure-py, Clojure на Python
    Ferret, для преобразования в C++11 бинарники
    Joker, для Go
    Las3r, Clojure для ActionScript Virtual Machine (Adobe Flash Player)
    Rouge, Clojure на YARV для Ruby

## Как писать на Clojure?

`;` -- комментарий

### Числа
```lisp
42        ; integer
-1.5      ; floating point
22/7      ; ratio
```

### Около строки
```lisp
"hello"         ; string
\e              ; character
#"[0-9]+"       ; regular expression
```

### Символы и всякое
```lisp
map             ; symbol
+               ; symbol - most punctuation allowed
clojure.core/+  ; namespaced symbol
nil             ; null value
true false      ; booleans
:alpha          ; keyword
:release/alpha  ; keyword with namespace
```

### Коллекции
```lisp
'(1 2 3)     ; list
[1 2 3]      ; vector
#{1 2 3}     ; set
{:a 1, :b 2} ; map
```

### **def**
```lisp
user=> (def x 7)
#'user/x
```
`def` присваивает символу (x) значение (7)
```lisp
user=> (+ x x)
14
```

### Печать в консоль
| &nbsp; | Human-Readable | Machine-Readable |
|-|-|-|
| With newline | println | prn |
| Without newline | print | pr |

```lisp
user=> (println "What is this:" (+ 1 2))
What is this: 3
```
```lisp
user=> (prn "one\n\ttwo")
"one\n\ttwo"
```

### Функции
**defn** создаёт именованную функцию:

```lisp
;;    name   params         body
;;    -----  ------  -------------------
(defn greet  [name]  (str "Hello, " name) )
```

```lisp
user=> (greet "students")
"Hello, students"
```

### Функции с разным количеством аргументов
```lisp
(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
```

```lisp
user=> (messenger)
Hello world!
nil

user=> (messenger "Hello class!")
Hello class!
nil
```

### Функции с динамическим количеством аргументов
Начало переменных параметров помечено `&`.
```lisp
(defn hello [greeting & who]
  (println greeting who))
```
Все агрументы, кроме первого будут собраны в список `who`
```lisp
user=> (hello "Hello" "world" "class")
Hello (world class)
```

### Анонимные функции
Анонимная функция может быть создана с помощью `fn`:
```lisp
;;    params         body
;;   ---------  -----------------
(fn  [message]  (println message) )
```
Поскольку анонимная функция не имеет имени, на нее нельзя ссылаться позже. Анонимная функция обычно создается в тот момент, когда она передается другой функции.
```lisp
;;     operation (function)             argument
;; --------------------------------  --------------
(  (fn [message] (println message))  "Hello world!" )

;; Hello world!
```